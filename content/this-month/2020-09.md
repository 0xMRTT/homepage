+++
title = "This Month in Rust OSDev (September 2020)"
date = 0000-01-01

[extra]
month = "September 2020"
authors = [
    "phil-opp",
    "IsaacWoods",
    # add yourself here
]
+++

Welcome to a new issue of _"This Month in Rust OSDev"_. In these posts, we will give a regular overview of notable changes in the Rust operating system development ecosystem.

<!-- more -->

This series is openly developed [on GitHub](https://github.com/rust-osdev/homepage/). Feel free to open pull requests there with content you would like to see in the next issue. If you find some issues on this page, please report them by [creating an issue](https://github.com/rust-osdev/homepage/issues/new).

<!--
    This is a draft for the upcoming "This Month in Rust OSDev (September 2020)" post.
    Feel free to create pull requests against the `next` branch to add your
    content here.
    Please take a look at the past posts on https://rust-osdev.com/ to see the
    general structure of these posts.
-->

## Project Updates

In this section, we give an overview of notable changes to the projects hosted under the [`rust-osdev`] organization.

[`rust-osdev`]: https://github.com/rust-osdev/about

### [`x86_64`](https://github.com/rust-osdev/x86_64)

The `x86_64` crate provides various abstractions for `x86_64` systems, including wrappers for CPU instructions, access to processor-specific registers, and abstraction types for architecture-specific structures such as page tables and descriptor tables.

In September, …

### [`acpi`](https://github.com/rust-osdev/acpi)
<span class="gray">(Section written by [@IsaacWoods](https://github.com/IsaacWoods))</span>
The `acpi` repository contains crates for parsing the ACPI tables – data structures that the firmware of modern computers use to relay information about the hardware to the OS. Lots of work happened this month:

* [Support](https://github.com/rust-osdev/acpi/pull/76) for the `Fixed Memory`, `Word Address Space`, `DWord Address Space`, `QWord Address Space`, `IRQ Format`,
  `DMA Format`, and `I/O Port Descriptor` resource descriptors were added. These appear in `_CRS` objects - objects
  that describe the resources allocated to a particular hardware device. This should be enough support to parse the
  `_CRS` objects of all devices supported by QEMU. Thanks to [`@michaelmelanson`](https://github.com/michaelmelanson) for his contribution!
* [Version `2.0.0` of the `acpi` crate was published](https://github.com/rust-osdev/acpi/pull/75), after [consultation with contributors to the Redox project](https://github.com/rust-osdev/acpi/issues/74).
  This splits the library into two parts - discovering ACPI tables using various methods, and separately, parsing them to discover information about the system.
  This provides much more flexibility in how tables are parsed, allows support for OS-specific tables, and is
  important to the Redox project as it allows parsing of the ACPI tables in userspace. We also used this
  opportunity for breaking changes to clean up a few parts of the library, especially in making our method of
  mapping physical memory ranges safer.
* A new crate, [rsdp](https://crates.io/crates/rsdp), was split out from `acpi`. This new crate provides methods
  for searching for the first ACPI table (the Root System Description Pointer (RSDP)) on BIOS systems without
  `alloc` support. This makes it suitable for use from bootloaders and similar applications where heap allocation
  is not supported. All types are reexported by the `acpi` crate, so users can access the same functionality from
  the main library.

### [`pci_types`](https://github.com/rust-osdev/pci_types)
<span class="gray">(Section written by [@IsaacWoods](https://github.com/IsaacWoods))</span>
`pci_types` is a new library in the Rust OSDev organisation that provides types for accessing and configuring PCI
devices from Rust operating systems. Lots of this code (e.g. identifying devices by class codes) can be shared
between projects, and would benefit from community contributions. This month, work started on some types for
representing PCIe addresses, the layout of the configuration space for *endpoints*, device types, and a trait that
allows the library to access the PCIe configuration space in whichever way the platform exposes it.

Thanks to [@toku-sa-n](https://github.com/toku-sa-n) for their [contribution](https://github.com/rust-osdev/pci_types/pull/1)!

## Personal Projects

In this section, we describe updates to personal projects that are not directly related to the `rust-osdev` organization. Feel free to [create a pull request](https://github.com/rust-osdev/homepage/pulls) with the updates of your OS project for the next post.

### [`phil-opp/blog_os`](https://github.com/phil-opp/blog_os)

<span class="gray">(Section written by [@phil-opp](https://github.com/phil-opp))</span>

This month, ...

### [`IsaacWoods/pebble`](https://github.com/IsaacWoods/pebble)
<span class="gray">(Section written by [@IsaacWoods](https://github.com/IsaacWoods))</span>

A fairly large amount of progress has been made on Pebble over the last two months, and a prototype of Pebble's
defining feature (easy message passing between tasks) is now working!

* The first, basic, version of Pebble's wire format, [ptah](https://github.com/IsaacWoods/pebble/tree/master/lib/ptah) has been completed.
  This first version is implemented as a Serde format, but libraries could be written for any language that can
  manipulate a byte stream.
* Two system calls, `send_message` and `get_message`, were added that allows a message (a series of bytes, and
  optionally a number of *handles* (effectively, permission to access a certain *kernel object*)) to be sent
  down a *channel*, between two tasks.
* Infrastructure for another of Pebble's key features, *services*, was added. This allows userspace tasks to
  advertise their ability to provide some kind of 'service' to other tasks. A task called [`echo`](https://github.com/IsaacWoods/pebble/blob/master/user/echo/src/main.rs)
  was built to test this - it provides a service that simply echos any messages sent down it back to the sending
  task.
* Work started on the Platform Bus, a concept inspired by another hobby OS [managarm's `mbus`](https://github.com/managarm/managarm/blob/master/docs/src/design/mbus/index.md).
  All hardware devices on the platform will be added to the Platform Bus by *Bus Drivers*, and described using *properties* (as an
  example, a PCI device will have properties such as `pci.vendor_id`, and `pci.class`). *Device drivers* will be
  able to apply to manage devices by sending a *Filter* to the Platform Bus, which specifies which devices they are
  able to handle, based on a device's properties. In the future, Platform Bus will be responsible for handling all
  PCI, USB, and hardwired devices on all platforms.
* The first *Bus Driver* was added to manage PCI devices. It uses a new system call, `pci_get_info`, to get the raw
  information about PCI from the kernel, and then creates a Platform Bus device for each function, with the correct
  properties. It uses the new `pci_types` library in the Rust OSDev organisation to identify each device (in the
  future, this will be extended to know about specific vendor+device ID combinations, to identify specific devices
  such as a particular graphics card).

### [`andre-richter/qemu-exit`](https://github.com/andre-richter/qemu-exit)

Version `1.0.x` of the crate has been released! 

`qemu-exit` is a crate that allows you quit a running QEMU session with a user-defined exit code. This is useful for `unit` or `integration tests` of bare-metal software (e.g. OS kernels) that are tested in QEMU.

The crate supports the following architectures:
- `AArch64`
- `RISC-V 64`
- `x86_64`

If you want to see the crate in action, you can have a look at how it is used in the [rust-raspberrypi-OS-tutorials project](https://github.com/rust-embedded/rust-raspberrypi-OS-tutorials/tree/master/13_integrated_testing#quitting-qemu-with-user-defined-exit-codes).

Shoutout to [@phil-opp](https://github.com/phil-opp) for inspiring this crate with his original blog post and to [@Skallwar](https://github.com/Skallwar) for his many contributions.

## Join Us?

Are you interested in Rust-based operating system development? Our `rust-osdev` organization is always open to new members and new projects. Just let us know if you want to join! A good way for getting in touch is our [gitter channel](https://gitter.im/rust-osdev/Lobby).


<!--
TODO: Update publication date
-->
